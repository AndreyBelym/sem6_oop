#ifndef ARRAY_H
#define ARRAY_H
/*!Класс "динамический массив".*/
class Array {
    private:
        double *data;//!<указатель-массив данных
        int size;//!<размер массива
    public:
        /*!Конструктор по умолчанию.*/
        Array();
        /*!Конструктор, выделяющий память под массив указанного размера.
         * \param len размер массива
         */
        Array(const int len);
        /*!Конструктор, создающий объект, используя указатель на массив
         * и размер массива.
         * \param new_data указатель на копируемые данные
         * \param len размер массива
         */
        Array(const double *new_data,const int len);
        /*!Конструктор копирования.
         * \param other копируемый массив
         */
        Array(const Array& other);
        /*!Деструктор класса.*/
        ~Array();
        /*!Установка размера массива.
         * При изменении размера освобождается выделенная память,
         * и захватывается новая, что может привести к потере данных.
         * \param len размер массива
         */
        void setLen(const int len);
        /*!Получение текущего размера массива.
         * \return размер массива.
         */
        int len();
        /*!Получение ссылки на элемент массива.
         * \param n индекс элемента
         * \return ссылка на значение элемента
         */
        double& valueAt(int n);
        /*!Получение ссылки на элемент массива(версия для объекта-константы).
         * \param n индекс элемента
         * \return ссылка на значение элемента
         */
        const double& valueAt(int n) const;
        /*!Установка значения элемента массива.
         * \param n индекс элемента
         * \param value ссылка на значение элемента
         */
        void setValueAt(const int n, double value);
        /*!Сортировка массива, после которой следуют сначала все отрицательные
         * элементы, затем положительные.
         * Относительное положение среди положительных и отрицательных 
         * элементов сохраняется такое же, как и в исходном массиве.*/
        void strangeSort();
        /*!Вывод массива на экран.*/
        void Print() const;
        /*!Копирование элементов другого массива по ссылке.
         * \param other копируемый массив
         */
        void Copy(const Array& other);
        /*!Перегруженный копирующий оператор присваивания.
         * \param other присваиваемый массив
         * \return данный список
         */
        Array& operator=(const Array& other);
        /*!Перегруженый оператор индексации - получение значения элемента
         * массива.
         * \param n индекс элемента
         * \return ссылка на значение элемента
         */
        double& operator[](const int n);
        /*!Перегруженый оператор индексации - получение значения элемента
         * массива(версия для объекта-константы).
         * \param n индекс элемента
         * \return ссылка на значение элемента
         */
        const double& operator[](const int n) const;
};
#endif //ARRAY_H
